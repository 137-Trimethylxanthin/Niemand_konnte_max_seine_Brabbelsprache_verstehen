//pc == process counter
//RISC V set
//Control and Status Registers (CSRs)

â³â˜ðŸ’¨ -> 0000 0000 //LUI (load upper immediate) i glab ane Const's ?
âž•â˜ðŸ’¨ðŸ’» -> 0000 0001 //AUIPC (add upper immediate to pc) is used to build pc-relative addresses and uses the U-type
ðŸ¦˜ -> 0000 0010 //JAL Unconditional Jumps JAL stores the address of the instruction following the jump (pc+4) into register rd.
ðŸ¦˜ðŸ”— -> 0000 0011 //JALR (jump and link register)
ðŸŒ³ðŸ™†â€â™‚ï¸ -> 0000 0100 //BEQ (Conditional Branches) Branch instructions compare two registers. are equal
ðŸŒ³ðŸ™…â€â™‚ï¸ -> 0000 0101 //BNE not equal
ðŸŒ³ðŸ¤ðŸ–‹ï¸ -> 0000 0110 //BLS less than singnd
ðŸŒ³ðŸ’â€â™‚ï¸ðŸ–‹ï¸ -> 0000 0111 //BGE greater than signd
ðŸŒ³ðŸ¤ðŸ” -> 0000 1000 //BLSU less than unsignd
ðŸŒ³ðŸ’â€â™‚ï¸ðŸ” -> 0000 1001 //BGEU greater than unsignde
â³ðŸ‘¾ðŸ–‹ï¸ -> 0000 1010 //LB loads an 8 bit val sign-extends this to XLEN
â³ðŸ‘¾ðŸ‘¾ðŸ–‹ï¸ -> 0000 1011 //LH loads an 16 bit val sign-extends this to XLEN
â³ðŸ‘¾ðŸ‘¾ðŸ‘¾ðŸ‘¾ðŸ–‹ï¸ -> 0000 1100 //LW loads an 32 bit val sign-extends this to XLEN
â³ðŸ‘¾ðŸ” -> 0000 1101 //LBU loads an 8 bit val 0-extends this to XLEN
â³ðŸ‘¾ðŸ‘¾ðŸ” -> 0000 1110 //LHU loads an 16 bit val 0-extends this to XLEN
ðŸªðŸ‘¾ -> 0000 1111 //SB Stores an 8 bit val from the low bits of register rs2 to memory.
ðŸªðŸ‘¾ðŸ‘¾ -> 0001 0000 //SH Stores an 16 bit val from the low bits of register rs2 to memory.
ðŸªðŸ‘¾ðŸ‘¾ðŸ‘¾ðŸ‘¾ -> 0001 0001 //SW Stores an 32 bit val from the low bits of register rs2 to memory.
âž•ðŸ’¨ -> 0001 0010 // ADDI adds the sign-extended 12-bit immediate to register rs1
ðŸª‘ðŸ¤ðŸ’¨ -> 0001 0011 //SLTI Place the value 1 in register rd if register rs1 is less than the signextended immediate else 0
ðŸª‘ðŸ¤ðŸ’¨ðŸ” -> 0001 0100 //SLTIU Place the value 1 in register rd if register rs1 is less than the signextended immediate else 0 unsignd
ðŸ¦»ðŸ’¨ -> 0001 0101 //XORI
ðŸ‘‚ðŸ’¨ -> 0001 0110 //ORI
ðŸ¤—ðŸ’¨ -> 0001 0111 //ANDI
ðŸ‘ˆðŸ’¨ -> 0001 1000 // SLLI Performs logical left shift on the value in register rs1 by the shift amount held in the lower 5 bits of the immediate
ðŸ‘‰ðŸ’¨ -> 0001 1001 // SRLI Performs logical right shift on the value in register rs1 by the shift amount held in the lower 5 bits of the immediate
ðŸ‘‰ðŸ§®ðŸ’¨ -> 0001 1010 // SRAI Performs arithmetic right shift on the value in register rs1 by the shift amount held in the lower 5 bits of the immediate
âž• -> 0001 1011 //ADD
âž– -> 0001 1100 //SUB
ðŸ‘ˆ -> 0001 1101 //SLL Performs logical left shift on the value in register rs1 by the shift amount held in the lower 5 bits of register rs2.
ðŸª‘ðŸ¤ -> 0001 1110 //SLT Place the value 1 in register rd if register rs1 is less than register rs2 when both are treated as signed numbers, else 0 is written to rd.
ðŸª‘ðŸ¤ðŸ” -> 0001 1111 //SLTU Place the value 1 in register rd if register rs1 is less than register rs2 when both are treated as unsigned numbers, else 0 is written to rd.
ðŸ¦» -> 0010 0000 //XOR
ðŸ‘‰ -> 0010 0001 //SRL Logical right shift on the value in register rs1 by the shift amount held in the lower 5 bits of register rs2
ðŸ‘‰ðŸ§® -> 0010 0010 //SRA Performs arithmetic right shift on the value in register rs1 by the shift amount held in the lower 5 bits of register rs2
ðŸ‘‚ -> 0010 0011 //OR
ðŸ¤— -> 0010 0100 //AND
ðŸš§ -> 0010 0101 //FENCE Used to order device I/O and memory accesses as viewed by other RISC-V harts and external devices or coprocessors.
ðŸš§â„¹ï¸ -> 0010 0110 //FENCE.I Provides explicit synchronization between writes to instruction memory and instruction fetches on the same hart (HARdware Thread).
â¸ -> 0010 0111 //PAUSE
âœ‹ -> 0010 1000 //PAUSE
ðŸ“ž -> 0010 1001 //ECALL - enviorment call exeptions
â¹ -> 0010 1010 //EBREAK - Stops execution SOFORT
â˜¢ï¸ðŸ“°âœï¸ -> 0010 1011 //CSRRW atomic read/write CSR. Atomically swaps values in the CSRs and integer registers. CSRRW reads the old value of the CSR, zero-extends the value to XLEN bits, then writes it to integer register rd.
ðŸª‘ðŸ“° -> 0010 1011 //CSRRS Reads the value of the CSR, zero-extends the value to XLEN bits, and writes it to integer register rd. The initial value in integer register rs1 is treated as a bit mask that specifies bit positions to be set in the CSR.
ðŸ§¼ðŸ“° -> 0010 1011 //CSRRC Reads the value of the CSR, zero-extends the value to XLEN bits, and writes it to integer register rd. The initial value in integer register rs1 is treated as a bit mask that specifies bit positions to be cleared in the CSR.
â˜¢ï¸ðŸ“°âœï¸ðŸ’¨ -> 0010 1111 //CSRRWI .
ðŸª‘ðŸ“°ðŸ’¨ -> 0011 0001 //CSRRSI  
ðŸ§¼ðŸ“°ðŸ’¨ -> 0011 0010 //CSRRCI  